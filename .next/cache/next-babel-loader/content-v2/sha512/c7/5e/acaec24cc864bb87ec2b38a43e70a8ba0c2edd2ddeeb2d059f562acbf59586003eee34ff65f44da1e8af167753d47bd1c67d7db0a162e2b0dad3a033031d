{"ast":null,"code":"const decryptZip = async (zipUint, imageUint, password) => {\n  const passwordUint = new TextEncoder().encode(password);\n  const baseKey = await crypto.subtle.importKey(\"raw\", passwordUint, {\n    name: \"PBKDF2\"\n  }, false, [\"deriveKey\"]);\n  const cryptoKey = await crypto.subtle.deriveKey({\n    name: \"PBKDF2\",\n    salt: imageUint.slice(0, 16),\n    // Use the image as salt\n    iterations: 10000,\n    hash: \"SHA-256\"\n  }, baseKey, {\n    name: \"AES-CTR\",\n    length: 128\n  }, false, [\"decrypt\"]);\n  const zipDecrypted = await crypto.subtle.decrypt({\n    name: \"AES-CTR\",\n    counter: new Uint8Array(16),\n    length: 128\n  }, cryptoKey, zipUint.buffer);\n  return new Uint8Array(zipDecrypted);\n};\n\nonmessage = async ({\n  data: {\n    image: [{\n      contents,\n      type\n    }],\n    password\n  }\n}) => {\n  const imageUint = new Uint8Array(contents);\n  const marker = {\n    \"image/png\": [174, 66, 96, 130],\n    \"image/jpeg\": [255, 217],\n    \"image/gif\": [59]\n  }[type]; // Find where the ZIP starts by locating the marker\n\n  const indexOfZip = imageUint.findIndex((_, index) => imageUint.slice(index, index + marker.length).toString() === marker.toString()) + marker.length; // Slice the combined result to get the encrypted ZIP and separator + text\n\n  const zipAndDetailsUint = imageUint.slice(indexOfZip); // Convert to string to find the separator\n\n  const separator = \"::PATIENT_DETAILS::\";\n  const zipAndDetailsString = new TextDecoder().decode(zipAndDetailsUint);\n  const separatorIndex = zipAndDetailsString.indexOf(separator); // Split the encrypted ZIP and the patient details\n\n  const zipEncryptedUint = zipAndDetailsUint.slice(0, separatorIndex);\n  const patientDetailsUint = zipAndDetailsUint.slice(separatorIndex + separator.length); // Decrypt the ZIP data\n\n  const zipUint = await decryptZip(zipEncryptedUint, imageUint, password); // Decode the patient details from Uint8Array to string\n\n  const patientDetails = new TextDecoder().decode(patientDetailsUint); // Send back the decrypted ZIP and patient details\n\n  postMessage({\n    result: new Blob([zipUint], {\n      type: \"application/zip\"\n    }),\n    patientDetails // Send patient details back to the UI\n\n  });\n  close();\n};","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Find.worker.js"],"names":["decryptZip","zipUint","imageUint","password","passwordUint","TextEncoder","encode","baseKey","crypto","subtle","importKey","name","cryptoKey","deriveKey","salt","slice","iterations","hash","length","zipDecrypted","decrypt","counter","Uint8Array","buffer","onmessage","data","image","contents","type","marker","indexOfZip","findIndex","_","index","toString","zipAndDetailsUint","separator","zipAndDetailsString","TextDecoder","decode","separatorIndex","indexOf","zipEncryptedUint","patientDetailsUint","patientDetails","postMessage","result","Blob","close"],"mappings":"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","sourcesContent":["const decryptZip = async (zipUint, imageUint, password) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n    const baseKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        passwordUint,\r\n        {\r\n            name: \"PBKDF2\",\r\n        },\r\n        false,\r\n        [\"deriveKey\"]\r\n    );\r\n    const cryptoKey = await crypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt: imageUint.slice(0, 16), // Use the image as salt\r\n            iterations: 10000,\r\n            hash: \"SHA-256\",\r\n        },\r\n        baseKey,\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"decrypt\"]\r\n    );\r\n    const zipDecrypted = await crypto.subtle.decrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16),\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n    return new Uint8Array(zipDecrypted);\r\n};\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        password,\r\n    },\r\n}) => {\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const marker = {\r\n        \"image/png\": [174, 66, 96, 130],\r\n        \"image/jpeg\": [255, 217],\r\n        \"image/gif\": [59],\r\n    }[type];\r\n\r\n    // Find where the ZIP starts by locating the marker\r\n    const indexOfZip =\r\n        imageUint.findIndex(\r\n            (_, index) =>\r\n                imageUint.slice(index, index + marker.length).toString() ===\r\n                marker.toString()\r\n        ) + marker.length;\r\n\r\n    // Slice the combined result to get the encrypted ZIP and separator + text\r\n    const zipAndDetailsUint = imageUint.slice(indexOfZip);\r\n\r\n    // Convert to string to find the separator\r\n    const separator = \"::PATIENT_DETAILS::\";\r\n    const zipAndDetailsString = new TextDecoder().decode(zipAndDetailsUint);\r\n    const separatorIndex = zipAndDetailsString.indexOf(separator);\r\n\r\n    // Split the encrypted ZIP and the patient details\r\n    const zipEncryptedUint = zipAndDetailsUint.slice(0, separatorIndex);\r\n    const patientDetailsUint = zipAndDetailsUint.slice(separatorIndex + separator.length);\r\n\r\n    // Decrypt the ZIP data\r\n    const zipUint = await decryptZip(zipEncryptedUint, imageUint, password);\r\n\r\n    // Decode the patient details from Uint8Array to string\r\n    const patientDetails = new TextDecoder().decode(patientDetailsUint);\r\n\r\n    // Send back the decrypted ZIP and patient details\r\n    postMessage({\r\n        result: new Blob([zipUint], { type: \"application/zip\" }),\r\n        patientDetails, // Send patient details back to the UI\r\n    });\r\n\r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"script"}