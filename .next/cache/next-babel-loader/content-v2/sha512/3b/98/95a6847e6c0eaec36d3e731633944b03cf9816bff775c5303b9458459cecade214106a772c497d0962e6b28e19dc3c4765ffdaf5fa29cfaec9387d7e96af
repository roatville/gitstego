{"ast":null,"code":"var _slicedToArray = require(\"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar decryptZip = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(zipUint, imageUint, password) {\n    var passwordUint, baseKey, cryptoKey, zipDecrypted;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            passwordUint = new TextEncoder().encode(password);\n            _context.next = 3;\n            return crypto.subtle.importKey(\"raw\", passwordUint, {\n              name: \"PBKDF2\"\n            }, false, [\"deriveKey\"]);\n\n          case 3:\n            baseKey = _context.sent;\n            _context.next = 6;\n            return crypto.subtle.deriveKey({\n              name: \"PBKDF2\",\n              salt: imageUint.slice(0, 16),\n              iterations: 10000,\n              hash: \"SHA-256\"\n            }, baseKey, {\n              name: \"AES-CTR\",\n              length: 128\n            }, false, [\"decrypt\"]);\n\n          case 6:\n            cryptoKey = _context.sent;\n            _context.next = 9;\n            return crypto.subtle.decrypt({\n              name: \"AES-CTR\",\n              counter: new Uint8Array(16),\n              length: 128\n            }, cryptoKey, zipUint.buffer);\n\n          case 9:\n            zipDecrypted = _context.sent;\n            return _context.abrupt(\"return\", new Uint8Array(zipDecrypted));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function decryptZip(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nonmessage = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var _ref2$data, _ref2$data$image, _ref2$data$image$, contents, type, password, imageUint, marker, indexOfZip, zipEncryptedUint, zipUint;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2$data = _ref2.data, _ref2$data$image = _slicedToArray(_ref2$data.image, 1), _ref2$data$image$ = _ref2$data$image[0], contents = _ref2$data$image$.contents, type = _ref2$data$image$.type, password = _ref2$data.password;\n            imageUint = new Uint8Array(contents);\n            marker = {\n              \"image/png\": [174, 66, 96, 130],\n              \"image/jpeg\": [255, 217],\n              \"image/gif\": [59]\n            }[type];\n            indexOfZip = imageUint.findIndex(function (_, index) {\n              return imageUint.slice(index, index + marker.length).toString() === marker.toString();\n            }) + marker.length;\n            zipEncryptedUint = imageUint.slice(indexOfZip);\n            _context2.next = 7;\n            return decryptZip(zipEncryptedUint, imageUint, password);\n\n          case 7:\n            zipUint = _context2.sent;\n            postMessage({\n              result: new Blob([zipUint], {\n                type: \"application/zip\"\n              })\n            });\n            close();\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function onmessage(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Find.worker.js"],"names":["decryptZip","zipUint","imageUint","password","passwordUint","TextEncoder","encode","crypto","subtle","importKey","name","baseKey","deriveKey","salt","slice","iterations","hash","length","cryptoKey","decrypt","counter","Uint8Array","buffer","zipDecrypted","onmessage","data","image","contents","type","marker","indexOfZip","findIndex","_","index","toString","zipEncryptedUint","postMessage","result","Blob","close"],"mappings":";;;;;;AAAA,IAAMA,UAAU;AAAA,sEAAG,iBAAOC,OAAP,EAAgBC,SAAhB,EAA2BC,QAA3B;AAAA;AAAA;AAAA;AAAA;AAAA;AACTC,YAAAA,YADS,GACM,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBH,QAAzB,CADN;AAAA;AAAA,mBAEOI,MAAM,CAACC,MAAP,CAAcC,SAAd,CAClB,KADkB,EAElBL,YAFkB,EAGlB;AACIM,cAAAA,IAAI,EAAE;AADV,aAHkB,EAMlB,KANkB,EAOlB,CAAC,WAAD,CAPkB,CAFP;;AAAA;AAETC,YAAAA,OAFS;AAAA;AAAA,mBAWSJ,MAAM,CAACC,MAAP,CAAcI,SAAd,CACpB;AACIF,cAAAA,IAAI,EAAE,QADV;AAEIG,cAAAA,IAAI,EAAEX,SAAS,CAACY,KAAV,CAAgB,CAAhB,EAAmB,EAAnB,CAFV;AAGIC,cAAAA,UAAU,EAAE,KAHhB;AAIIC,cAAAA,IAAI,EAAE;AAJV,aADoB,EAOpBL,OAPoB,EAQpB;AACID,cAAAA,IAAI,EAAE,SADV;AAEIO,cAAAA,MAAM,EAAE;AAFZ,aARoB,EAYpB,KAZoB,EAapB,CAAC,SAAD,CAboB,CAXT;;AAAA;AAWTC,YAAAA,SAXS;AAAA;AAAA,mBA0BYX,MAAM,CAACC,MAAP,CAAcW,OAAd,CACvB;AACIT,cAAAA,IAAI,EAAE,SADV;AAEIU,cAAAA,OAAO,EAAE,IAAIC,UAAJ,CAAe,EAAf,CAFb;AAGIJ,cAAAA,MAAM,EAAE;AAHZ,aADuB,EAMvBC,SANuB,EAOvBjB,OAAO,CAACqB,MAPe,CA1BZ;;AAAA;AA0BTC,YAAAA,YA1BS;AAAA,6CAmCR,IAAIF,UAAJ,CAAeE,YAAf,CAnCQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAVvB,UAAU;AAAA;AAAA;AAAA,GAAhB;;AAsCAwB,SAAS;AAAA,uEAAG;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,+BACRC,IADQ,+CAEJC,KAFI,+CAEMC,QAFN,qBAEMA,QAFN,EAEgBC,IAFhB,qBAEgBA,IAFhB,EAGJzB,QAHI,cAGJA,QAHI;AAMFD,YAAAA,SANE,GAMU,IAAImB,UAAJ,CAAeM,QAAf,CANV;AAQFE,YAAAA,MARE,GAQO;AACX,2BAAa,CAAC,GAAD,EAAM,EAAN,EAAU,EAAV,EAAc,GAAd,CADF;AAEX,4BAAc,CAAC,GAAD,EAAM,GAAN,CAFH;AAGX,2BAAa,CAAC,EAAD;AAHF,cAIbD,IAJa,CARP;AAcFE,YAAAA,UAdE,GAeJ5B,SAAS,CAAC6B,SAAV,CACI,UAACC,CAAD,EAAIC,KAAJ;AAAA,qBACI/B,SAAS,CAACY,KAAV,CAAgBmB,KAAhB,EAAuBA,KAAK,GAAGJ,MAAM,CAACZ,MAAtC,EAA8CiB,QAA9C,OACAL,MAAM,CAACK,QAAP,EAFJ;AAAA,aADJ,IAIIL,MAAM,CAACZ,MAnBP;AAqBFkB,YAAAA,gBArBE,GAqBiBjC,SAAS,CAACY,KAAV,CAAgBgB,UAAhB,CArBjB;AAAA;AAAA,mBAsBc9B,UAAU,CAACmC,gBAAD,EAAmBjC,SAAnB,EAA8BC,QAA9B,CAtBxB;;AAAA;AAsBFF,YAAAA,OAtBE;AAwBRmC,YAAAA,WAAW,CAAC;AACRC,cAAAA,MAAM,EAAE,IAAIC,IAAJ,CAAS,CAACrC,OAAD,CAAT,EAAoB;AAAE2B,gBAAAA,IAAI,EAAE;AAAR,eAApB;AADA,aAAD,CAAX;AAGAW,YAAAA,KAAK;;AA3BG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA;AAAA;AAAA;AAAA,GAAT","sourcesContent":["const decryptZip = async (zipUint, imageUint, password) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n    const baseKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        passwordUint,\r\n        {\r\n            name: \"PBKDF2\",\r\n        },\r\n        false,\r\n        [\"deriveKey\"]\r\n    );\r\n    const cryptoKey = await crypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt: imageUint.slice(0, 16),\r\n            iterations: 10000,\r\n            hash: \"SHA-256\",\r\n        },\r\n        baseKey,\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"decrypt\"]\r\n    );\r\n    const zipDecrypted = await crypto.subtle.decrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16),\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n    return new Uint8Array(zipDecrypted);\r\n};\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        password,\r\n    },\r\n}) => {\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const marker = {\r\n        \"image/png\": [174, 66, 96, 130],\r\n        \"image/jpeg\": [255, 217],\r\n        \"image/gif\": [59],\r\n    }[type];\r\n\r\n    const indexOfZip =\r\n        imageUint.findIndex(\r\n            (_, index) =>\r\n                imageUint.slice(index, index + marker.length).toString() ===\r\n                marker.toString()\r\n        ) + marker.length;\r\n\r\n    const zipEncryptedUint = imageUint.slice(indexOfZip);\r\n    const zipUint = await decryptZip(zipEncryptedUint, imageUint, password);\r\n\r\n    postMessage({\r\n        result: new Blob([zipUint], { type: \"application/zip\" }),\r\n    });\r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"script"}