{"ast":null,"code":"import JSZip from \"jszip\";\n\nconst encryptZip = async (zipUint, imageUint, password, text) => {\n  const passwordUint = new TextEncoder().encode(password);\n  const baseKey = await crypto.subtle.importKey(\"raw\", passwordUint, \"PBKDF2\", false, [\"deriveBits\", \"deriveKey\"]);\n  const cryptoKey = await crypto.subtle.deriveKey({\n    name: \"PBKDF2\",\n    salt: imageUint.slice(0, 16),\n    iterations: 10000,\n    hash: \"SHA-256\"\n  }, baseKey, {\n    name: \"AES-CTR\",\n    length: 128\n  }, false, [\"encrypt\"]);\n  const zipEncrypted = await crypto.subtle.encrypt({\n    name: \"AES-CTR\",\n    counter: new Uint8Array(16),\n    length: 128\n  }, cryptoKey, zipUint.buffer); // Convert the patient details text to Uint8Array and append it\n\n  const textUint = new TextEncoder().encode(text); // Combine image, encrypted zip, and text\n\n  const resultUint = new Uint8Array([...imageUint, ...new Uint8Array(zipEncrypted), ...textUint]);\n  return resultUint;\n};\n\nonmessage = async ({\n  data: {\n    image: [{\n      contents,\n      type\n    }],\n    files,\n    compression,\n    password,\n    text\n  }\n}) => {\n  const zip = new JSZip();\n  files.forEach(file => {\n    const {\n      name,\n      contents,\n      date\n    } = file;\n    zip.file(name, contents, {\n      date\n    });\n  });\n  const imageUint = new Uint8Array(contents);\n  const zipUint = await zip.generateAsync({\n    type: \"uint8array\",\n    compression: compression === 0 ? \"STORE\" : \"DEFLATE\",\n    compressionOptions: {\n      level: compression\n    }\n  }, ({\n    percent\n  }) => {\n    postMessage({\n      progress: percent\n    });\n  }); // const zipEncryptedUint = await encryptZip(zipUint, imageUint, password);\n  // const resultUint = new Uint8Array([...imageUint, ...zipEncryptedUint]);\n\n  const resultUint = await encryptZip(zipUint, imageUint, password, text);\n  postMessage({\n    result: new Blob([resultUint], {\n      type\n    })\n  });\n  close();\n};","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Hide.worker.js"],"names":["JSZip","encryptZip","zipUint","imageUint","password","text","passwordUint","TextEncoder","encode","baseKey","crypto","subtle","importKey","cryptoKey","deriveKey","name","salt","slice","iterations","hash","length","zipEncrypted","encrypt","counter","Uint8Array","buffer","textUint","resultUint","onmessage","data","image","contents","type","files","compression","zip","forEach","file","date","generateAsync","compressionOptions","level","percent","postMessage","progress","result","Blob","close"],"mappings":"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","sourcesContent":["import JSZip from \"jszip\";\r\n\r\nconst encryptZip = async (zipUint, imageUint, password, text) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n    const baseKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        passwordUint,\r\n        \"PBKDF2\",\r\n        false,\r\n        [\"deriveBits\", \"deriveKey\"]\r\n    );\r\n    const cryptoKey = await crypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt: imageUint.slice(0, 16),\r\n            iterations: 10000,\r\n            hash: \"SHA-256\",\r\n        },\r\n        baseKey,\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"encrypt\"]\r\n    );\r\n    const zipEncrypted = await crypto.subtle.encrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16),\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n     // Convert the patient details text to Uint8Array and append it\r\n     const textUint = new TextEncoder().encode(text);\r\n    \r\n     // Combine image, encrypted zip, and text\r\n     const resultUint = new Uint8Array([...imageUint, ...new Uint8Array(zipEncrypted), ...textUint]);\r\n \r\n     return resultUint;\r\n};\r\n\r\n\r\n\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        files,\r\n        compression,\r\n        password,\r\n        text,\r\n    },\r\n}) => {\r\n    const zip = new JSZip();\r\n    files.forEach((file) => {\r\n        const { name, contents, date } = file;\r\n        zip.file(name, contents, {\r\n            date,\r\n        });\r\n    });\r\n\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const zipUint = await zip.generateAsync(\r\n        {\r\n            type: \"uint8array\",\r\n            compression: compression === 0 ? \"STORE\" : \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: compression,\r\n            },\r\n        },\r\n        ({ percent }) => {\r\n            postMessage({ progress: percent });\r\n        }\r\n    );\r\n\r\n    // const zipEncryptedUint = await encryptZip(zipUint, imageUint, password);\r\n    // const resultUint = new Uint8Array([...imageUint, ...zipEncryptedUint]);\r\n\r\n    const resultUint = await encryptZip(zipUint, imageUint, password, text);\r\n\r\n\r\n    postMessage({\r\n        result: new Blob([resultUint], { type }),\r\n    });\r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}