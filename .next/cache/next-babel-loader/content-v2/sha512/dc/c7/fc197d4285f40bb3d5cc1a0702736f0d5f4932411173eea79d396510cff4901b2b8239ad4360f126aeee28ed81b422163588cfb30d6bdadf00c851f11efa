{"ast":null,"code":"import _slicedToArray from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { argon2 } from \"argon2-browser\"; // Import the Argon2 library\n\nvar decryptZip = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(zipUint, imageUint, password) {\n    var passwordUint, argon2Options, hash, cryptoKey, zipDecrypted;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            passwordUint = new TextEncoder().encode(password); // Derive the key using Argon2\n\n            argon2Options = {\n              pass: passwordUint,\n              // password as Uint8Array\n              salt: imageUint.slice(0, 16),\n              // Use the first 16 bytes of imageUint as the salt\n              time: 1,\n              // Argon2 parameter: number of iterations\n              mem: 1024,\n              // Argon2 parameter: memory usage in KiB\n              hashLen: 16,\n              // length of the generated key\n              parallelism: 1,\n              // number of threads\n              type: argon2.ArgonType.Argon2id // Argon2id is the recommended version for password hashing\n\n            };\n            _context.next = 4;\n            return argon2.hash(argon2Options);\n\n          case 4:\n            hash = _context.sent;\n            _context.next = 7;\n            return crypto.subtle.importKey(\"raw\", hash.hash, // Use the derived key from Argon2\n            {\n              name: \"AES-CTR\",\n              length: 128\n            }, false, [\"decrypt\"]);\n\n          case 7:\n            cryptoKey = _context.sent;\n            _context.next = 10;\n            return crypto.subtle.decrypt({\n              name: \"AES-CTR\",\n              counter: new Uint8Array(16),\n              // Counter should be 16 bytes\n              length: 128\n            }, cryptoKey, zipUint.buffer);\n\n          case 10:\n            zipDecrypted = _context.sent;\n            return _context.abrupt(\"return\", new Uint8Array(zipDecrypted));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function decryptZip(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nonmessage = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var _ref2$data, _ref2$data$image, _ref2$data$image$, contents, type, password, imageUint, marker, indexOfZip, zipEncryptedUint, zipUint;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2$data = _ref2.data, _ref2$data$image = _slicedToArray(_ref2$data.image, 1), _ref2$data$image$ = _ref2$data$image[0], contents = _ref2$data$image$.contents, type = _ref2$data$image$.type, password = _ref2$data.password;\n            imageUint = new Uint8Array(contents);\n            marker = {\n              \"image/png\": [174, 66, 96, 130],\n              \"image/jpeg\": [255, 217],\n              \"image/gif\": [59]\n            }[type];\n            indexOfZip = imageUint.findIndex(function (_, index) {\n              return imageUint.slice(index, index + marker.length).toString() === marker.toString();\n            }) + marker.length;\n            zipEncryptedUint = imageUint.slice(indexOfZip);\n            _context2.next = 7;\n            return decryptZip(zipEncryptedUint, imageUint, password);\n\n          case 7:\n            zipUint = _context2.sent;\n            postMessage({\n              result: new Blob([zipUint], {\n                type: \"application/zip\"\n              })\n            });\n            close();\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function onmessage(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Find.worker.js"],"names":["argon2","decryptZip","zipUint","imageUint","password","passwordUint","TextEncoder","encode","argon2Options","pass","salt","slice","time","mem","hashLen","parallelism","type","ArgonType","Argon2id","hash","crypto","subtle","importKey","name","length","cryptoKey","decrypt","counter","Uint8Array","buffer","zipDecrypted","onmessage","data","image","contents","marker","indexOfZip","findIndex","_","index","toString","zipEncryptedUint","postMessage","result","Blob","close"],"mappings":"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","sourcesContent":["import { argon2 } from \"argon2-browser\"; // Import the Argon2 library\r\n\r\nconst decryptZip = async (zipUint, imageUint, password) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n\r\n    // Derive the key using Argon2\r\n    const argon2Options = {\r\n        pass: passwordUint, // password as Uint8Array\r\n        salt: imageUint.slice(0, 16), // Use the first 16 bytes of imageUint as the salt\r\n        time: 1, // Argon2 parameter: number of iterations\r\n        mem: 1024, // Argon2 parameter: memory usage in KiB\r\n        hashLen: 16, // length of the generated key\r\n        parallelism: 1, // number of threads\r\n        type: argon2.ArgonType.Argon2id, // Argon2id is the recommended version for password hashing\r\n    };\r\n\r\n    const hash = await argon2.hash(argon2Options); // Derive the key using Argon2\r\n\r\n    const cryptoKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        hash.hash, // Use the derived key from Argon2\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"decrypt\"]\r\n    );\r\n\r\n    const zipDecrypted = await crypto.subtle.decrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16), // Counter should be 16 bytes\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n\r\n    return new Uint8Array(zipDecrypted);\r\n};\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        password,\r\n    },\r\n}) => {\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const marker = {\r\n        \"image/png\": [174, 66, 96, 130],\r\n        \"image/jpeg\": [255, 217],\r\n        \"image/gif\": [59],\r\n    }[type];\r\n\r\n    const indexOfZip =\r\n        imageUint.findIndex(\r\n            (_, index) =>\r\n                imageUint.slice(index, index + marker.length).toString() ===\r\n                marker.toString()\r\n        ) + marker.length;\r\n\r\n    const zipEncryptedUint = imageUint.slice(indexOfZip);\r\n    const zipUint = await decryptZip(zipEncryptedUint, imageUint, password);\r\n\r\n    postMessage({\r\n        result: new Blob([zipUint], { type: \"application/zip\" }),\r\n    });\r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}