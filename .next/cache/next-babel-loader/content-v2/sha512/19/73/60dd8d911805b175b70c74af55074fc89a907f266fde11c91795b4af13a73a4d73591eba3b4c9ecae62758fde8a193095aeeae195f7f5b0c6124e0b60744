{"ast":null,"code":"var _slicedToArray = require(\"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar decryptZip = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(zipUint, imageUint, password) {\n    var passwordUint, baseKey, cryptoKey, zipDecrypted;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            passwordUint = new TextEncoder().encode(password);\n            _context.next = 3;\n            return crypto.subtle.importKey(\"raw\", passwordUint, {\n              name: \"PBKDF2\"\n            }, false, [\"deriveKey\"]);\n\n          case 3:\n            baseKey = _context.sent;\n            _context.next = 6;\n            return crypto.subtle.deriveKey({\n              name: \"PBKDF2\",\n              salt: imageUint.slice(0, 16),\n              // Use the image as salt\n              iterations: 10000,\n              hash: \"SHA-256\"\n            }, baseKey, {\n              name: \"AES-CTR\",\n              length: 128\n            }, false, [\"decrypt\"]);\n\n          case 6:\n            cryptoKey = _context.sent;\n            _context.next = 9;\n            return crypto.subtle.decrypt({\n              name: \"AES-CTR\",\n              counter: new Uint8Array(16),\n              length: 128\n            }, cryptoKey, zipUint.buffer);\n\n          case 9:\n            zipDecrypted = _context.sent;\n            return _context.abrupt(\"return\", new Uint8Array(zipDecrypted));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function decryptZip(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nonmessage = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var _ref2$data, _ref2$data$image, _ref2$data$image$, contents, type, password, imageUint, marker, indexOfZip, zipAndDetailsUint, zipEndIndex, zipEncryptedUint, patientDetailsUint, zipUint, patientDetails;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2$data = _ref2.data, _ref2$data$image = _slicedToArray(_ref2$data.image, 1), _ref2$data$image$ = _ref2$data$image[0], contents = _ref2$data$image$.contents, type = _ref2$data$image$.type, password = _ref2$data.password;\n            imageUint = new Uint8Array(contents);\n            marker = {\n              \"image/png\": [174, 66, 96, 130],\n              \"image/jpeg\": [255, 217],\n              \"image/gif\": [59]\n            }[type]; // Find where the ZIP starts by locating the marker\n\n            indexOfZip = imageUint.findIndex(function (_, index) {\n              return imageUint.slice(index, index + marker.length).toString() === marker.toString();\n            }) + marker.length; // Slice the combined result to get the encrypted ZIP and patient details\n\n            zipAndDetailsUint = imageUint.slice(indexOfZip); // Determine the ZIP end and patient details start (we need a marker or fixed size to separate them)\n\n            zipEndIndex = zipAndDetailsUint.length - 1000; // Assuming last 1000 bytes are for the patient details\n\n            zipEncryptedUint = zipAndDetailsUint.slice(0, zipEndIndex);\n            patientDetailsUint = zipAndDetailsUint.slice(zipEndIndex); // Last part contains the patient details\n            // Decrypt the ZIP data\n\n            _context2.next = 10;\n            return decryptZip(zipEncryptedUint, imageUint, password);\n\n          case 10:\n            zipUint = _context2.sent;\n            // Decode the patient details from Uint8Array to string\n            patientDetails = new TextDecoder().decode(patientDetailsUint); // Send back the decrypted ZIP and patient details\n\n            postMessage({\n              result: new Blob([zipUint], {\n                type: \"application/zip\"\n              }),\n              patientDetails: patientDetails // Send patient details back to the UI\n\n            });\n            close();\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function onmessage(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Find.worker.js"],"names":["decryptZip","zipUint","imageUint","password","passwordUint","TextEncoder","encode","crypto","subtle","importKey","name","baseKey","deriveKey","salt","slice","iterations","hash","length","cryptoKey","decrypt","counter","Uint8Array","buffer","zipDecrypted","onmessage","data","image","contents","type","marker","indexOfZip","findIndex","_","index","toString","zipAndDetailsUint","zipEndIndex","zipEncryptedUint","patientDetailsUint","patientDetails","TextDecoder","decode","postMessage","result","Blob","close"],"mappings":"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","sourcesContent":["const decryptZip = async (zipUint, imageUint, password) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n    const baseKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        passwordUint,\r\n        {\r\n            name: \"PBKDF2\",\r\n        },\r\n        false,\r\n        [\"deriveKey\"]\r\n    );\r\n    const cryptoKey = await crypto.subtle.deriveKey(\r\n        {\r\n            name: \"PBKDF2\",\r\n            salt: imageUint.slice(0, 16), // Use the image as salt\r\n            iterations: 10000,\r\n            hash: \"SHA-256\",\r\n        },\r\n        baseKey,\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"decrypt\"]\r\n    );\r\n    const zipDecrypted = await crypto.subtle.decrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16),\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n    return new Uint8Array(zipDecrypted);\r\n};\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        password,\r\n    },\r\n}) => {\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const marker = {\r\n        \"image/png\": [174, 66, 96, 130],\r\n        \"image/jpeg\": [255, 217],\r\n        \"image/gif\": [59],\r\n    }[type];\r\n\r\n    // Find where the ZIP starts by locating the marker\r\n    const indexOfZip =\r\n        imageUint.findIndex(\r\n            (_, index) =>\r\n                imageUint.slice(index, index + marker.length).toString() ===\r\n                marker.toString()\r\n        ) + marker.length;\r\n\r\n    // Slice the combined result to get the encrypted ZIP and patient details\r\n    const zipAndDetailsUint = imageUint.slice(indexOfZip);\r\n\r\n    // Determine the ZIP end and patient details start (we need a marker or fixed size to separate them)\r\n    const zipEndIndex = zipAndDetailsUint.length - 1000; // Assuming last 1000 bytes are for the patient details\r\n    const zipEncryptedUint = zipAndDetailsUint.slice(0, zipEndIndex);\r\n    const patientDetailsUint = zipAndDetailsUint.slice(zipEndIndex); // Last part contains the patient details\r\n\r\n    // Decrypt the ZIP data\r\n    const zipUint = await decryptZip(zipEncryptedUint, imageUint, password);\r\n\r\n    // Decode the patient details from Uint8Array to string\r\n    const patientDetails = new TextDecoder().decode(patientDetailsUint);\r\n\r\n    // Send back the decrypted ZIP and patient details\r\n    postMessage({\r\n        result: new Blob([zipUint], { type: \"application/zip\" }),\r\n        patientDetails, // Send patient details back to the UI\r\n    });\r\n    \r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"script"}