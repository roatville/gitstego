{"ast":null,"code":"import _toConsumableArray from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport JSZip from \"jszip\";\nimport { argon2 } from \"argon2-browser\"; // Import the Argon2 library\n\nvar encryptZip = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(zipUint, imageUint, password) {\n    var passwordUint, argon2Options, hash, cryptoKey, zipEncrypted;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            passwordUint = new TextEncoder().encode(password); // Derive the key using Argon2\n\n            argon2Options = {\n              pass: passwordUint,\n              // password as Uint8Array\n              salt: imageUint.slice(0, 16),\n              // Use the first 16 bytes of imageUint as the salt\n              time: 1,\n              // Argon2 parameter: number of iterations\n              mem: 1024,\n              // Argon2 parameter: memory usage in KiB\n              hashLen: 16,\n              // length of the generated key\n              parallelism: 1,\n              // number of threads\n              type: argon2.ArgonType.Argon2id // Argon2id is the recommended version for password hashing\n\n            };\n            _context.next = 4;\n            return argon2.hash(argon2Options);\n\n          case 4:\n            hash = _context.sent;\n            _context.next = 7;\n            return crypto.subtle.importKey(\"raw\", hash.hash, // Use the derived key from Argon2\n            {\n              name: \"AES-CTR\",\n              length: 128\n            }, false, [\"encrypt\"]);\n\n          case 7:\n            cryptoKey = _context.sent;\n            _context.next = 10;\n            return crypto.subtle.encrypt({\n              name: \"AES-CTR\",\n              counter: new Uint8Array(16),\n              // Counter should be 16 bytes\n              length: 128\n            }, cryptoKey, zipUint.buffer);\n\n          case 10:\n            zipEncrypted = _context.sent;\n            return _context.abrupt(\"return\", new Uint8Array(zipEncrypted));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function encryptZip(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nonmessage = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var _ref2$data, _ref2$data$image, _ref2$data$image$, contents, type, files, compression, password, zip, imageUint, zipUint, zipEncryptedUint, resultUint;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2$data = _ref2.data, _ref2$data$image = _slicedToArray(_ref2$data.image, 1), _ref2$data$image$ = _ref2$data$image[0], contents = _ref2$data$image$.contents, type = _ref2$data$image$.type, files = _ref2$data.files, compression = _ref2$data.compression, password = _ref2$data.password;\n            zip = new JSZip();\n            files.forEach(function (file) {\n              var name = file.name,\n                  contents = file.contents,\n                  date = file.date;\n              zip.file(name, contents, {\n                date: date\n              });\n            });\n            imageUint = new Uint8Array(contents);\n            _context2.next = 6;\n            return zip.generateAsync({\n              type: \"uint8array\",\n              compression: compression === 0 ? \"STORE\" : \"DEFLATE\",\n              compressionOptions: {\n                level: compression\n              }\n            }, function (_ref4) {\n              var percent = _ref4.percent;\n              postMessage({\n                progress: percent\n              });\n            });\n\n          case 6:\n            zipUint = _context2.sent;\n            _context2.next = 9;\n            return encryptZip(zipUint, imageUint, password);\n\n          case 9:\n            zipEncryptedUint = _context2.sent;\n            resultUint = new Uint8Array([].concat(_toConsumableArray(imageUint), _toConsumableArray(zipEncryptedUint)));\n            postMessage({\n              result: new Blob([resultUint], {\n                type: type\n              })\n            });\n            close();\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function onmessage(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Hide.worker.js"],"names":["JSZip","argon2","encryptZip","zipUint","imageUint","password","passwordUint","TextEncoder","encode","argon2Options","pass","salt","slice","time","mem","hashLen","parallelism","type","ArgonType","Argon2id","hash","crypto","subtle","importKey","name","length","cryptoKey","encrypt","counter","Uint8Array","buffer","zipEncrypted","onmessage","data","image","contents","files","compression","zip","forEach","file","date","generateAsync","compressionOptions","level","percent","postMessage","progress","zipEncryptedUint","resultUint","result","Blob","close"],"mappings":"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","sourcesContent":["import JSZip from \"jszip\";\r\nimport { argon2 } from \"argon2-browser\"; // Import the Argon2 library\r\n\r\nconst encryptZip = async (zipUint, imageUint, password) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n\r\n    // Derive the key using Argon2\r\n    const argon2Options = {\r\n        pass: passwordUint, // password as Uint8Array\r\n        salt: imageUint.slice(0, 16), // Use the first 16 bytes of imageUint as the salt\r\n        time: 1, // Argon2 parameter: number of iterations\r\n        mem: 1024, // Argon2 parameter: memory usage in KiB\r\n        hashLen: 16, // length of the generated key\r\n        parallelism: 1, // number of threads\r\n        type: argon2.ArgonType.Argon2id, // Argon2id is the recommended version for password hashing\r\n    };\r\n\r\n    const hash = await argon2.hash(argon2Options); // Derive the key using Argon2\r\n\r\n    const cryptoKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        hash.hash, // Use the derived key from Argon2\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"encrypt\"]\r\n    );\r\n\r\n    const zipEncrypted = await crypto.subtle.encrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16), // Counter should be 16 bytes\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n\r\n    return new Uint8Array(zipEncrypted);\r\n};\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        files,\r\n        compression,\r\n        password,\r\n    },\r\n}) => {\r\n    const zip = new JSZip();\r\n    files.forEach((file) => {\r\n        const { name, contents, date } = file;\r\n        zip.file(name, contents, {\r\n            date,\r\n        });\r\n    });\r\n\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const zipUint = await zip.generateAsync(\r\n        {\r\n            type: \"uint8array\",\r\n            compression: compression === 0 ? \"STORE\" : \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: compression,\r\n            },\r\n        },\r\n        ({ percent }) => {\r\n            postMessage({ progress: percent });\r\n        }\r\n    );\r\n\r\n    const zipEncryptedUint = await encryptZip(zipUint, imageUint, password);\r\n    const resultUint = new Uint8Array([...imageUint, ...zipEncryptedUint]);\r\n\r\n    postMessage({\r\n        result: new Blob([resultUint], { type }),\r\n    });\r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}