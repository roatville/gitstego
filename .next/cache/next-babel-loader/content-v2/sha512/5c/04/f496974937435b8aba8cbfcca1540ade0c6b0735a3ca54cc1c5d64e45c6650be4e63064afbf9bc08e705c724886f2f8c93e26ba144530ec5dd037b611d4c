{"ast":null,"code":"import JSZip from \"jszip\";\nimport { argon2 } from \"argon2-browser\"; // Import the Argon2 library\n\nconst encryptZip = async (zipUint, imageUint, password) => {\n  const passwordUint = new TextEncoder().encode(password); // Derive the key using Argon2\n\n  const argon2Options = {\n    pass: passwordUint,\n    // password as Uint8Array\n    salt: imageUint.slice(0, 16),\n    // Use the first 16 bytes of imageUint as the salt\n    time: 1,\n    // Argon2 parameter: number of iterations\n    mem: 1024,\n    // Argon2 parameter: memory usage in KiB\n    hashLen: 16,\n    // length of the generated key\n    parallelism: 1,\n    // number of threads\n    type: argon2.ArgonType.Argon2id // Argon2id is the recommended version for password hashing\n\n  };\n  const hash = await argon2.hash(argon2Options); // Derive the key using Argon2\n\n  const cryptoKey = await crypto.subtle.importKey(\"raw\", hash.hash, // Use the derived key from Argon2\n  {\n    name: \"AES-CTR\",\n    length: 128\n  }, false, [\"encrypt\"]);\n  const zipEncrypted = await crypto.subtle.encrypt({\n    name: \"AES-CTR\",\n    counter: new Uint8Array(16),\n    // Counter should be 16 bytes\n    length: 128\n  }, cryptoKey, zipUint.buffer);\n  return new Uint8Array(zipEncrypted);\n};\n\nonmessage = async ({\n  data: {\n    image: [{\n      contents,\n      type\n    }],\n    files,\n    compression,\n    password\n  }\n}) => {\n  const zip = new JSZip();\n  files.forEach(file => {\n    const {\n      name,\n      contents,\n      date\n    } = file;\n    zip.file(name, contents, {\n      date\n    });\n  });\n  const imageUint = new Uint8Array(contents);\n  const zipUint = await zip.generateAsync({\n    type: \"uint8array\",\n    compression: compression === 0 ? \"STORE\" : \"DEFLATE\",\n    compressionOptions: {\n      level: compression\n    }\n  }, ({\n    percent\n  }) => {\n    postMessage({\n      progress: percent\n    });\n  });\n  const zipEncryptedUint = await encryptZip(zipUint, imageUint, password);\n  const resultUint = new Uint8Array([...imageUint, ...zipEncryptedUint]);\n  postMessage({\n    result: new Blob([resultUint], {\n      type\n    })\n  });\n  close();\n};","map":{"version":3,"sources":["R:/VIT Research/Research Papers for topics/Stegnography for medical imaging/portalwebsite/gitstego/workers/Hide.worker.js"],"names":["JSZip","argon2","encryptZip","zipUint","imageUint","password","passwordUint","TextEncoder","encode","argon2Options","pass","salt","slice","time","mem","hashLen","parallelism","type","ArgonType","Argon2id","hash","cryptoKey","crypto","subtle","importKey","name","length","zipEncrypted","encrypt","counter","Uint8Array","buffer","onmessage","data","image","contents","files","compression","zip","forEach","file","date","generateAsync","compressionOptions","level","percent","postMessage","progress","zipEncryptedUint","resultUint","result","Blob","close"],"mappings":"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","sourcesContent":["import JSZip from \"jszip\";\r\nimport { argon2 } from \"argon2-browser\"; // Import the Argon2 library\r\n\r\nconst encryptZip = async (zipUint, imageUint, password) => {\r\n    const passwordUint = new TextEncoder().encode(password);\r\n\r\n    // Derive the key using Argon2\r\n    const argon2Options = {\r\n        pass: passwordUint, // password as Uint8Array\r\n        salt: imageUint.slice(0, 16), // Use the first 16 bytes of imageUint as the salt\r\n        time: 1, // Argon2 parameter: number of iterations\r\n        mem: 1024, // Argon2 parameter: memory usage in KiB\r\n        hashLen: 16, // length of the generated key\r\n        parallelism: 1, // number of threads\r\n        type: argon2.ArgonType.Argon2id, // Argon2id is the recommended version for password hashing\r\n    };\r\n\r\n    const hash = await argon2.hash(argon2Options); // Derive the key using Argon2\r\n\r\n    const cryptoKey = await crypto.subtle.importKey(\r\n        \"raw\",\r\n        hash.hash, // Use the derived key from Argon2\r\n        {\r\n            name: \"AES-CTR\",\r\n            length: 128,\r\n        },\r\n        false,\r\n        [\"encrypt\"]\r\n    );\r\n\r\n    const zipEncrypted = await crypto.subtle.encrypt(\r\n        {\r\n            name: \"AES-CTR\",\r\n            counter: new Uint8Array(16), // Counter should be 16 bytes\r\n            length: 128,\r\n        },\r\n        cryptoKey,\r\n        zipUint.buffer\r\n    );\r\n\r\n    return new Uint8Array(zipEncrypted);\r\n};\r\n\r\nonmessage = async ({\r\n    data: {\r\n        image: [{ contents, type }],\r\n        files,\r\n        compression,\r\n        password,\r\n    },\r\n}) => {\r\n    const zip = new JSZip();\r\n    files.forEach((file) => {\r\n        const { name, contents, date } = file;\r\n        zip.file(name, contents, {\r\n            date,\r\n        });\r\n    });\r\n\r\n    const imageUint = new Uint8Array(contents);\r\n\r\n    const zipUint = await zip.generateAsync(\r\n        {\r\n            type: \"uint8array\",\r\n            compression: compression === 0 ? \"STORE\" : \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: compression,\r\n            },\r\n        },\r\n        ({ percent }) => {\r\n            postMessage({ progress: percent });\r\n        }\r\n    );\r\n\r\n    const zipEncryptedUint = await encryptZip(zipUint, imageUint, password);\r\n    const resultUint = new Uint8Array([...imageUint, ...zipEncryptedUint]);\r\n\r\n    postMessage({\r\n        result: new Blob([resultUint], { type }),\r\n    });\r\n    close();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}